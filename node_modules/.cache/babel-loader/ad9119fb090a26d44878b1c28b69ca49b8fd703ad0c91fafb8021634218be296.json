{"ast":null,"code":"import { ref, onMounted, onBeforeUnmount } from 'vue';\n\n/**\n * Props\n * - links: array of { label, href } items\n * - triggerSelector: CSS selector for the element to observe (default: '.hero')\n *   The nav moves to the top when this element is no longer intersecting the viewport.\n * - offsetTopPx: positive number to trigger a bit earlier/later (via rootMargin)\n */\n\nexport default {\n  __name: 'FooterComponent',\n  props: {\n    links: {\n      type: Array,\n      default: () => [{\n        label: 'About',\n        href: '#about'\n      }, {\n        label: 'Program',\n        href: '#program'\n      }, {\n        label: 'Tickets',\n        href: '#tickets'\n      }, {\n        label: 'Contact',\n        href: '#contact'\n      }]\n    },\n    triggerSelector: {\n      type: String,\n      default: '.hero'\n    },\n    offsetTopPx: {\n      type: Number,\n      default: 0\n    }\n  },\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const props = __props;\n    const atTop = ref(false);\n    let observer = null;\n    onMounted(() => {\n      const el = document.querySelector(props.triggerSelector);\n      // Fallback: if we can't find the trigger, just switch on scroll\n      if (!el) {\n        const onScroll = () => atTop.value = window.scrollY > 10;\n        onScroll();\n        window.addEventListener('scroll', onScroll, {\n          passive: true\n        });\n        observer = {\n          disconnect: () => window.removeEventListener('scroll', onScroll)\n        };\n        return;\n      }\n\n      // When the trigger leaves the viewport, set atTop = true\n      observer = new IntersectionObserver(entries => {\n        for (const entry of entries) {\n          // If NOT intersecting -> user scrolled past trigger -> stick to top\n          atTop.value = !entry.isIntersecting;\n        }\n      }, {\n        root: null,\n        threshold: 0,\n        rootMargin: `-${props.offsetTopPx}px 0px 0px 0px`\n      });\n      observer.observe(el);\n    });\n    onBeforeUnmount(() => {\n      observer?.disconnect?.();\n    });\n    const __returned__ = {\n      props,\n      atTop,\n      get observer() {\n        return observer;\n      },\n      set observer(v) {\n        observer = v;\n      },\n      ref,\n      onMounted,\n      onBeforeUnmount\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","onMounted","onBeforeUnmount","props","__props","atTop","observer","el","document","querySelector","triggerSelector","onScroll","value","window","scrollY","addEventListener","passive","disconnect","removeEventListener","IntersectionObserver","entries","entry","isIntersecting","root","threshold","rootMargin","offsetTopPx","observe"],"sources":["/Users/lucasteindorf/Documents/Programmierung/WebDev/web-template/src/components/FooterComponent.vue"],"sourcesContent":["<template>\n  <nav class=\"nav-strip\" :class=\"{ atTop }\" aria-label=\"Main navigation\">\n    <ul>\n      <li v-for=\"(item, i) in links\" :key=\"i\">\n        <a :href=\"item.href\">{{ item.label }}</a>\n      </li>\n      <slot />\n    </ul>\n  </nav>\n</template>\n\n<script setup>\nimport { ref, onMounted, onBeforeUnmount } from 'vue'\n\n/**\n * Props\n * - links: array of { label, href } items\n * - triggerSelector: CSS selector for the element to observe (default: '.hero')\n *   The nav moves to the top when this element is no longer intersecting the viewport.\n * - offsetTopPx: positive number to trigger a bit earlier/later (via rootMargin)\n */\nconst props = defineProps({\n  links: {\n    type: Array,\n    default: () => ([\n      { label: 'About', href: '#about' },\n      { label: 'Program', href: '#program' },\n      { label: 'Tickets', href: '#tickets' },\n      { label: 'Contact', href: '#contact' },\n    ]),\n  },\n  triggerSelector: {\n    type: String,\n    default: '.hero',\n  },\n  offsetTopPx: {\n    type: Number,\n    default: 0,\n  },\n})\n\nconst atTop = ref(false)\nlet observer = null\n\nonMounted(() => {\n  const el = document.querySelector(props.triggerSelector)\n  // Fallback: if we can't find the trigger, just switch on scroll\n  if (!el) {\n    const onScroll = () => (atTop.value = window.scrollY > 10)\n    onScroll()\n    window.addEventListener('scroll', onScroll, { passive: true })\n    observer = { disconnect: () => window.removeEventListener('scroll', onScroll) }\n    return\n  }\n\n  // When the trigger leaves the viewport, set atTop = true\n  observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        // If NOT intersecting -> user scrolled past trigger -> stick to top\n        atTop.value = !entry.isIntersecting\n      }\n    },\n    {\n      root: null,\n      threshold: 0,\n      rootMargin: `-${props.offsetTopPx}px 0px 0px 0px`,\n    }\n  )\n  observer.observe(el)\n})\n\nonBeforeUnmount(() => {\n  observer?.disconnect?.()\n})\n</script>\n\n<style scoped>\n.nav-strip {\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0; /* start at bottom */\n  z-index: 50;\n\n  background: rgba(20, 20, 20, 0.6);\n  -webkit-backdrop-filter: blur(8px);\n  backdrop-filter: blur(8px);\n\n  border-top: 1px solid rgba(255,255,255,0.15);\n  padding: 10px clamp(12px, 4vw, 28px) calc(10px + env(safe-area-inset-bottom));\n\n  transition:\n    transform 320ms ease,\n    background 200ms ease,\n    bottom 0s linear 0s,\n    top 0s linear 0s;\n}\n\n.nav-strip.atTop {\n  top: 0;\n  bottom: auto;\n  border-top: none;\n  border-bottom: 1px solid rgba(255,255,255,0.15);\n  background: rgba(20, 20, 20, 0.7);\n}\n\n.nav-strip ul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n\n  display: flex;\n  gap: clamp(12px, 4vw, 32px);\n  align-items: center;\n  justify-content: center;\n}\n\n.nav-strip a {\n  color: #fff;\n  text-decoration: none;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  padding: 8px 2px;\n}\n.nav-strip a:hover,\n.nav-strip a:focus {\n  text-decoration: underline;\n}\n</style>\n"],"mappings":"AAYA,SAASA,GAAG,EAAEC,SAAS,EAAEC,eAAe,QAAQ,KAAI;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACA,MAAMC,KAAK,GAAGC,OAAA;IAoBd,MAAMC,KAAK,GAAGL,GAAG,CAAC,KAAK;IACvB,IAAIM,QAAQ,GAAG,IAAG;IAElBL,SAAS,CAAC,MAAM;MACd,MAAMM,EAAE,GAAGC,QAAQ,CAACC,aAAa,CAACN,KAAK,CAACO,eAAe;MACvD;MACA,IAAI,CAACH,EAAE,EAAE;QACP,MAAMI,QAAQ,GAAGA,CAAA,KAAON,KAAK,CAACO,KAAK,GAAGC,MAAM,CAACC,OAAO,GAAG,EAAE;QACzDH,QAAQ,CAAC;QACTE,MAAM,CAACE,gBAAgB,CAAC,QAAQ,EAAEJ,QAAQ,EAAE;UAAEK,OAAO,EAAE;QAAK,CAAC;QAC7DV,QAAQ,GAAG;UAAEW,UAAU,EAAEA,CAAA,KAAMJ,MAAM,CAACK,mBAAmB,CAAC,QAAQ,EAAEP,QAAQ;QAAE;QAC9E;MACF;;MAEA;MACAL,QAAQ,GAAG,IAAIa,oBAAoB,CAChCC,OAAO,IAAK;QACX,KAAK,MAAMC,KAAK,IAAID,OAAO,EAAE;UAC3B;UACAf,KAAK,CAACO,KAAK,GAAG,CAACS,KAAK,CAACC,cAAa;QACpC;MACF,CAAC,EACD;QACEC,IAAI,EAAE,IAAI;QACVC,SAAS,EAAE,CAAC;QACZC,UAAU,EAAE,IAAItB,KAAK,CAACuB,WAAW;MACnC,CACF;MACApB,QAAQ,CAACqB,OAAO,CAACpB,EAAE;IACrB,CAAC;IAEDL,eAAe,CAAC,MAAM;MACpBI,QAAQ,EAAEW,UAAU,GAAG;IACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}