{"ast":null,"code":"import { ref, onMounted, onBeforeUnmount } from 'vue';\n\n/**\n * Behavior:\n * - While the hero bottom is within the viewport (rect.bottom > 0),\n *   the nav’s bottom edge matches the hero’s bottom.\n * - Once hero bottom <= 0, the nav sticks to the top.\n */\n\nexport default {\n  __name: 'NavStripeComponent',\n  props: {\n    links: {\n      type: Array,\n      default: () => [{\n        label: 'About',\n        href: '#about'\n      }, {\n        label: 'Program',\n        href: '#program'\n      }, {\n        label: 'Tickets',\n        href: '#tickets'\n      }, {\n        label: 'Contact',\n        href: '#contact'\n      }]\n    },\n    triggerSelector: {\n      type: String,\n      default: '.hero'\n    } // the element to “follow”\n  },\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const props = __props;\n    const atTop = ref(false);\n    const bottomPx = ref(0);\n    const navEl = ref(null);\n    let onScrollRaf = null;\n    let ticking = false;\n    let triggerEl = null;\n    function compute() {\n      if (!triggerEl) return;\n      const rect = triggerEl.getBoundingClientRect();\n      // If the bottom edge of the image is above the top of the viewport → stick to top\n      atTop.value = rect.bottom <= 0;\n      if (!atTop.value) {\n        // Distance from viewport bottom to hero bottom\n        // bottom CSS for fixed elements is from viewport bottom.\n        const dist = Math.max(window.innerHeight - rect.bottom, 0);\n        bottomPx.value = dist;\n      }\n    }\n    function onScroll() {\n      if (ticking) return;\n      ticking = true;\n      onScrollRaf = requestAnimationFrame(() => {\n        compute();\n        ticking = false;\n      });\n    }\n    onMounted(() => {\n      triggerEl = document.querySelector(props.triggerSelector);\n      compute();\n      window.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n      window.addEventListener('resize', compute);\n    });\n    onBeforeUnmount(() => {\n      window.removeEventListener('scroll', onScroll);\n      window.removeEventListener('resize', compute);\n      if (onScrollRaf) cancelAnimationFrame(onScrollRaf);\n    });\n    const __returned__ = {\n      props,\n      atTop,\n      bottomPx,\n      navEl,\n      get onScrollRaf() {\n        return onScrollRaf;\n      },\n      set onScrollRaf(v) {\n        onScrollRaf = v;\n      },\n      get ticking() {\n        return ticking;\n      },\n      set ticking(v) {\n        ticking = v;\n      },\n      get triggerEl() {\n        return triggerEl;\n      },\n      set triggerEl(v) {\n        triggerEl = v;\n      },\n      compute,\n      onScroll,\n      ref,\n      onMounted,\n      onBeforeUnmount\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","onMounted","onBeforeUnmount","props","__props","atTop","bottomPx","navEl","onScrollRaf","ticking","triggerEl","compute","rect","getBoundingClientRect","value","bottom","dist","Math","max","window","innerHeight","onScroll","requestAnimationFrame","document","querySelector","triggerSelector","addEventListener","passive","removeEventListener","cancelAnimationFrame"],"sources":["/Users/lucasteindorf/Documents/Programmierung/WebDev/web-template/src/components/NavStripeComponent.vue"],"sourcesContent":["<template>\n  <nav\n    ref=\"navEl\"\n    class=\"nav-strip\"\n    :class=\"{ atTop }\"\n    :style=\"{ '--dyn-bottom': bottomPx + 'px' }\"\n    aria-label=\"Main navigation\"\n  >\n    <ul>\n      <li v-for=\"(item, i) in links\" :key=\"i\">\n        <a :href=\"item.href\">{{ item.label }}</a>\n      </li>\n      <slot />\n    </ul>\n  </nav>\n</template>\n\n<script setup>\nimport { ref, onMounted, onBeforeUnmount } from 'vue'\n\n/**\n * Behavior:\n * - While the hero bottom is within the viewport (rect.bottom > 0),\n *   the nav’s bottom edge matches the hero’s bottom.\n * - Once hero bottom <= 0, the nav sticks to the top.\n */\nconst props = defineProps({\n  links: {\n    type: Array,\n    default: () => ([\n      { label: 'About', href: '#about' },\n      { label: 'Program', href: '#program' },\n      { label: 'Tickets', href: '#tickets' },\n      { label: 'Contact', href: '#contact' },\n    ]),\n  },\n  triggerSelector: { type: String, default: '.hero' }, // the element to “follow”\n})\n\nconst atTop = ref(false)\nconst bottomPx = ref(0)\nconst navEl = ref(null)\n\nlet onScrollRaf = null\nlet ticking = false\nlet triggerEl = null\n\nfunction compute() {\n  if (!triggerEl) return\n\n  const rect = triggerEl.getBoundingClientRect()\n  // If the bottom edge of the image is above the top of the viewport → stick to top\n  atTop.value = rect.bottom <= 0\n\n  if (!atTop.value) {\n    // Distance from viewport bottom to hero bottom\n    // bottom CSS for fixed elements is from viewport bottom.\n    const dist = Math.max(window.innerHeight - rect.bottom, 0)\n    bottomPx.value = dist\n  }\n}\n\nfunction onScroll() {\n  if (ticking) return\n  ticking = true\n  onScrollRaf = requestAnimationFrame(() => {\n    compute()\n    ticking = false\n  })\n}\n\nonMounted(() => {\n  triggerEl = document.querySelector(props.triggerSelector)\n  compute()\n  window.addEventListener('scroll', onScroll, { passive: true })\n  window.addEventListener('resize', compute)\n})\n\nonBeforeUnmount(() => {\n  window.removeEventListener('scroll', onScroll)\n  window.removeEventListener('resize', compute)\n  if (onScrollRaf) cancelAnimationFrame(onScrollRaf)\n})\n</script>\n\n<style scoped>\n.nav-strip {\n  position: fixed;\n  left: 0;\n  right: 0;\n  z-index: 50;\n\n  /* Start aligned to viewport bottom; JS updates --dyn-bottom to follow hero */\n  bottom: var(--dyn-bottom, 0px);\n\n  background: rgb(10, 11, 26);\n  -webkit-backdrop-filter: blur(8px);\n  backdrop-filter: blur(8px);\n\n  \n  padding: 10px clamp(12px, 4vw, 28px) calc(10px + env(safe-area-inset-bottom));\n\n  transition:\n    background 200ms ease,\n    transform 220ms ease;\n}\n\n/* When hero bottom goes above viewport top, stick to top */\n.nav-strip.atTop {\n  top: 0;\n  bottom: auto;\n  border-top: none;\n  border-bottom: 1px solid rgba(255,255,255,0.15);\n  background: rgba(20, 20, 20, 0.7);\n}\n\n.nav-strip ul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n\n  display: flex;\n  gap: clamp(12px, 4vw, 32px);\n  align-items: center;\n  justify-content: center;\n}\n\n.nav-strip a {\n  color: #fff;\n  text-decoration: none;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  padding: 8px 2px;\n}\n\n.nav-strip a:hover,\n.nav-strip a:focus {\n  text-decoration: underline;\n}\n</style>\n"],"mappings":"AAkBA,SAASA,GAAG,EAAEC,SAAS,EAAEC,eAAe,QAAQ,KAAI;;AAEpD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACA,MAAMC,KAAK,GAAGC,OAAA;IAad,MAAMC,KAAK,GAAGL,GAAG,CAAC,KAAK;IACvB,MAAMM,QAAQ,GAAGN,GAAG,CAAC,CAAC;IACtB,MAAMO,KAAK,GAAGP,GAAG,CAAC,IAAI;IAEtB,IAAIQ,WAAW,GAAG,IAAG;IACrB,IAAIC,OAAO,GAAG,KAAI;IAClB,IAAIC,SAAS,GAAG,IAAG;IAEnB,SAASC,OAAOA,CAAA,EAAG;MACjB,IAAI,CAACD,SAAS,EAAE;MAEhB,MAAME,IAAI,GAAGF,SAAS,CAACG,qBAAqB,CAAC;MAC7C;MACAR,KAAK,CAACS,KAAK,GAAGF,IAAI,CAACG,MAAM,IAAI;MAE7B,IAAI,CAACV,KAAK,CAACS,KAAK,EAAE;QAChB;QACA;QACA,MAAME,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACC,MAAM,CAACC,WAAW,GAAGR,IAAI,CAACG,MAAM,EAAE,CAAC;QACzDT,QAAQ,CAACQ,KAAK,GAAGE,IAAG;MACtB;IACF;IAEA,SAASK,QAAQA,CAAA,EAAG;MAClB,IAAIZ,OAAO,EAAE;MACbA,OAAO,GAAG,IAAG;MACbD,WAAW,GAAGc,qBAAqB,CAAC,MAAM;QACxCX,OAAO,CAAC;QACRF,OAAO,GAAG,KAAI;MAChB,CAAC;IACH;IAEAR,SAAS,CAAC,MAAM;MACdS,SAAS,GAAGa,QAAQ,CAACC,aAAa,CAACrB,KAAK,CAACsB,eAAe;MACxDd,OAAO,CAAC;MACRQ,MAAM,CAACO,gBAAgB,CAAC,QAAQ,EAAEL,QAAQ,EAAE;QAAEM,OAAO,EAAE;MAAK,CAAC;MAC7DR,MAAM,CAACO,gBAAgB,CAAC,QAAQ,EAAEf,OAAO;IAC3C,CAAC;IAEDT,eAAe,CAAC,MAAM;MACpBiB,MAAM,CAACS,mBAAmB,CAAC,QAAQ,EAAEP,QAAQ;MAC7CF,MAAM,CAACS,mBAAmB,CAAC,QAAQ,EAAEjB,OAAO;MAC5C,IAAIH,WAAW,EAAEqB,oBAAoB,CAACrB,WAAW;IACnD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}